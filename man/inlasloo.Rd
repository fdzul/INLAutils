% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inlasloo.R
\name{inlasloo}
\alias{inlasloo}
\title{A function to run a spatial leave-one-out cross-validation in R using INLA.}
\usage{
inlasloo(
  dataframe,
  long,
  lat,
  y,
  ss,
  rad,
  modform,
  family,
  mesh,
  ntrials = NULL,
  int.strategy = "eb",
  alpha = 0.05,
  mae = FALSE,
  ds = FALSE,
  sqroot = FALSE,
  print = FALSE,
  plot = TRUE,
  ...
)
}
\arguments{
\item{dataframe}{dataframe including the variables to be used}

\item{long}{Character string giving the name of the longitude variable}

\item{lat}{Character string giving the name of the latitude variable}

\item{y}{Character string giving the names of the response}

\item{ss}{Numeric value giving the sample size to process (number of SLOO runs)}

\item{rad}{Numeric value giving the radius for the spatial buffer around left-out point's location}

\item{modform}{Formula or list of Formula for the model or models, respectively in INLA format}

\item{family}{Character string or list of Character string giving the family or families, respectively of the response in INLA format}

\item{mesh}{inla.mesh object, consisting in triangle mesh to be defined using INLA.}

\item{ntrials}{vector of positive integers c(1,2,...) setting the number of trials for a Binomial family}

\item{int.strategy}{Character string giving INLA integration strategy}

\item{alpha}{Numeric value (0,...,1) giving the threshold for computing confidence intervals (1-alpha) of rmse and mae estimation}

\item{mae}{If TRUE, compute the mean absolute error (mae) and the root mean square error (rmse). If FALSE, compute the rmse only.}

\item{ds}{If TRUE, compute the Dawid-Sebastiani score (ds). If FALSE, does not compute ds.}

\item{sqroot}{If TRUE, compute the square root of the observed and predicted values to generate the rmse and/or mae. 
If FALSE, the rmse and/or mae are computed without transformation of the data.}

\item{print}{Logical to determine whether to print a summary of the results.}

\item{plot}{Logical to determine whether to print the plot of the results.}

\item{...}{other arguments passed to inla}
}
\description{
This function will apply a spatial leave-one-out cross-validation (SLOO-CV) of one or several models running on INLA.
The function requires a dataframe that includes a response, coordinates (longitude, latidude). 
Covariates can be inluced as well in the dataframe. Furthermore, the user needs to provide a radius
around which points will be removed during the SLOO-CV process. The number of iterations needs to be provided as well. 
Also the user needs to provide INLA inputs, including: formula, family (and ntrials for Binomial), and mesh
In addition, one can provide further INLA specifications, such as int.strategy='eb'.
SLOO-CV computes the root mean square error (rmse) with a tolerance for confidence interval defined by the user. 
In option, other scores can be computed, such as the mean absolute error, dawid-sebastiani or using square root of the data.
}
\examples{
 \dontrun{
require(INLA)
require(sp)
require(grDevices)

# generate a dataframe and INLA output for the function
set.seed(10)
coords <- data.frame(long = c(rnorm(70), rnorm(30, 3)), lat = rnorm(100))
PA <- rep(c(0, 1), each = 50)
x <- data.frame(x1 = rnorm(100),x2 = c(rnorm(70), rnorm(30, 2)))# x1 no relat., x2 pos. relat.
dataf1 <- sp::SpatialPointsDataFrame(coords = coords, data = data.frame(y = PA, x))
mesh <- INLA::inla.mesh.2d(loc = sp::coordinates(dataf1),max.edge = c(3, 3),cutoff = 1.3)
spde <- INLA::inla.spde2.matern(mesh, alpha=2)#SPDE model is defined
A <- INLA::inla.spde.make.A(mesh, loc = sp::coordinates(dataf1))#projector matrix
dataframe <- data.frame(dataf1) #generate dataframe with response and covariate
modform<-stats::as.formula(paste('y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)'))
stk <- INLA::inla.stack(data=list(y=dataframe$y),A=list(A, 1),
effects=list(list(spatial.field=1:spde$n.spde),
list(y.intercept=rep(1,length(dataframe$y)),covariate=dataframe[c(-1)])),tag='est')
out <- INLA::inla(modform, family='normal',Ntrials = 1, data=INLA::inla.stack.data(stk, spde=spde),
                  control.predictor = list(A=INLA::inla.stack.A(stk),link=1),
                  control.compute = list( config=TRUE),control.inla = list(int.strategy='eb'))
out.field <- INLA::inla.spde2.result(out,'spatial.field', spde, do.transf=TRUE)
range.out <- INLA::inla.emarginal(function(x) x, out.field$marginals.range.nominal[[1]])

# parameters for the SLOO process
ss <- 1#sample size to process (number of SLOO runs)
rad <- range.out*0.15#define the radius of the spatial buffer surrounding the removed point
mesh <- mesh#use the mesh of the model
dataframe <- dataframe#dataframe with response 'y' and covariates 'x1', 'x2'
dataframe$y <- round(runif(length(dataframe$y), 1, 12))#create positive discrete response
modform <- stats::as.formula(paste('y ~ -1+ y.intercept + x1 + f(spatial.field, model=spde)'))
family <- list('gamma')#one model
ntrials <- rep(round(max(dataframe$y,na.rm=TRUE)*2),length(dataframe$y))# create ntrials for Binomial family
alpha <- 0.05#rmse and mae confidence intervals (1-alpha)

# run the function
inlasloo(dataframe=dataframe, long='long', lat='lat',y= 'y', ss=ss, rad=rad,
modform=modform,mesh=mesh,family=family,alpha=0.05,mae=TRUE,ds=TRUE,sqroot=FALSE)

# SLOO function with one model formula (Binomial) and linear terms
sloo1<-inlasloo(dataframe=dataframe, long='long', lat='lat', y='y', ss=1, rad=0.1,
ntrials=ntrials,modform='y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)',mesh=mesh,
family='binomial',alpha=0.05,mae=FALSE,ds=FALSE,sqroot=FALSE)

# SLOO function with two families (Binomial and Poisson) and linear terms
sloo2<-inlasloo(dataframe=dataframe, long='long', lat='lat', y='y', ss=1, rad=0.1,
ntrials=ntrials,modform='y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)',mesh=mesh,
family=list('binomial','poisson'),alpha=0.05,mae=TRUE,ds=FALSE,sqroot=FALSE)

# SLOO function with one family (Binomial) and two model formulas
sloo3<-inlasloo(dataframe=dataframe, long='long', lat='lat', y='y', ss=1,
rad=0.1, ntrials=ntrials,modform=list('y ~ -1+ y.intercept + f(spatial.field, model=spde)',
'y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)'),
mesh=mesh,family='binomial',alpha=0.05,mae=TRUE,ds=FALSE,sqroot=FALSE)
 
# SLOO function with two families (Binomial and Poisson), two model formulas, 
# and MAE, DS, and sqroot activated
sloo4<-inlasloo(dataframe=dataframe, long='long', lat='lat', y='y', ss=1,
rad=0.1, ntrials=ntrials,modform=list('y ~ -1+ y.intercept + f(spatial.field, model=spde)',
'y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)'),
mesh=mesh,list('binomial','poisson'),alpha=0.05,mae=TRUE,ds=TRUE,sqroot=TRUE)
}
}
